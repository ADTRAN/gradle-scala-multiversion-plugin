/*
 * Copyright 2017 ADTRAN, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
            mavenCentral()
        }
    }

    dependencies {
        classpath "net.saliman:gradle-cobertura-plugin:4.+"
        classpath "com.gradle.publish:plugin-publish-plugin:0.12.0"
    }
}


plugins {
    id "nebula.dependency-lock" version "11.1.3"
    id "net.saliman.cobertura" version "4.0.0"
    id "groovy"
    // id "maven"
    id "java-gradle-plugin"
    id "com.gradle.plugin-publish" version "0.12.0"
    id "maven-publish"
    id "de.gliderpilot.semantic-release" version "1.4.1"
    id "signing"
}

group = artifact_group

sourceCompatibility = 1.6
targetCompatibility = 1.6

gradlePlugin {
    plugins {
        scalaMultiVersionPlugin {
            id = "${group}.${artifact_name}"
            implementationClass = "com.adtran.ScalaMultiVersionPlugin"
        }
    }
}

pluginBundle {
    website = 'https://github.com/ADTRAN/gradle-scala-multiversion-plugin'
    vcsUrl = 'https://github.com/ADTRAN/gradle-scala-multiversion-plugin'
    description = 'Gradle plugin to build a project against multiple versions of scala'
    tags = ['scala', 'versioning']
    plugins {
        scalaMultiVersionPlugin {
            id = "${group}.${artifact_name}"
            displayName = 'Scala Multi-Version Plugin'
        }
    }
}

dependencyLock {
    includeTransitives = true
}
task freeze(dependsOn: ['generateLock', 'saveLock'])

repositories {
    mavenCentral()
}

dependencies {
    implementation localGroovy()

    testImplementation 'junit:junit:4.12'
}

def pomConfig = {
    scm {
        connection 'scm:git:https://github.com/ADTRAN/gradle-scala-multiversion-plugin.git'
        developerConnection 'scm:git:ssh://git@github.com:ADTRAN/gradle-scala-multiversion-plugin.git'
        url 'https://github.com/ADTRAN/gradle-scala-multiversion-plugin'
    }

    licenses {
        license {
            name 'Apache License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        }
    }

    developers {
        developer {
            name 'Nathan Alderson'
            email 'nathan.alderson@adtran.com'
            organization 'ADTRAN, Inc.'
            organizationUrl 'http://www.adtran.com/'
        }
    }
}

publishing {
    repositories {
        maven {
            def releaseRepo = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
            def snapshotRepo = "https://oss.sonatype.org/content/repositories/snapshots/"
            url = version.toString().endsWith('-SNAPSHOT') ? releaseRepo: snapshotRepo
            credentials {
                username = findProperty('ossrhUsername')
                password = findProperty('ossrhPassword')
            }
        }
    }

    publications {
        mavenPublication(MavenPublication) {
            afterEvaluate {
                from components.java
                artifact sourcesJar
                artifact javadocJar
                groupId "$groupId"
                artifactId 'scala-multiversion-plugin'
                version "$version"
                pom.withXml {
                    def root = asNode()
                    root.appendNode('description', 'Gradle plugin to build a project against multiple versions of scala')
                    root.appendNode('name', "$artifact_group:$artifact_name")
                    root.appendNode('url', 'https://github.com/ADTRAN/gradle-scala-multiversion-plugin')
                    root.children().last() + pomConfig
                }
            }
        }
    }
}

signing {
    def signingKey = findProperty("signingKey")
    def signingPassword = findProperty("signingPassword")
    useInMemoryPgpKeys(signingKey, signingPassword)
    sign publishing.publications.mavenPublication
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from groovydoc
    from 'README.rst'
}

groovydoc.overviewText = resources.text.fromString('Please see <a href="README.rst">README.rst</a>')

assemble.dependsOn("sourcesJar", "javadocJar")

artifacts {
    archives sourcesJar, javadocJar
}

def configureTestTask(Task task) {
    task.outputs.upToDateWhen { false }
    task.testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        stackTraceFilters "entryPoint"
    }
}
configureTestTask(project.tasks.test)

// Write the plugin's classpath to a file to share with the tests
task createClasspathManifest {
    def outputDir = file("$buildDir/$name")
    inputs.files sourceSets.main.runtimeClasspath
    outputs.dir outputDir
    doLast {
        outputDir.mkdirs()
        file("$outputDir/plugin-classpath.txt").text = sourceSets.main.runtimeClasspath.join("\n")
    }
}

// Add the classpath file to the test runtime classpath
dependencies {
    testRuntimeOnly files(createClasspathManifest)
}

project.ext.ghToken = project.hasProperty('ghToken') ? project.getProperty('ghToken') : System.getenv('GH_TOKEN') ?: null
semanticRelease {
    repo {
        ghToken = project.ghToken
        releaseAsset jar
        releaseAsset sourcesJar, name: "sources.jar", label: 'sources jar', contentType: 'application/zip'
        releaseAsset javadocJar, name: "javadoc.jar", label: 'javadoc jar', contentType: 'application/zip'
    }
}

publish.dependsOn publishPlugins

prepare.doFirst  {
  //We get grgit for free because we are using semantic-release
  if(grgit.branch.getCurrent().name == "main" && version.toString().endsWith('-SNAPSHOT') && project.gradle.startParameter.taskNames.find { it == 'release' }) {
    println """We are on the main branch, but the version is ending in -SNAPSHOT. The version only gets -SNAPSHOT dropped if:
      * We are on the main branch
      * The repo is clean
      * There is a commit prefixed with 'fix:' or 'feat:' since the last release

      If none of those things happened on the main branch then we will still land in the snapshot version strategy and have a version number with -SNAPSHOT.

      See here for more details:

      https://github.com/tschulte/gradle-semantic-release-plugin
      """
      throw new GradleException('Releasing -SNAPSHOT version on main branch')
  }
}

task dummy() {
    doLast {
        print(project.tasks.withType(GenerateMavenPom))
    }
}

test {
    testLogging {
        outputs.upToDateWhen {false}
        showStandardStreams = true
    }
}
